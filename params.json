{"name":"Octarine","tagline":"Java 8 functional magic","body":"octarine\r\n========\r\n\r\n[![Build Status](https://travis-ci.org/poetix/octarine.svg?branch=master)](https://travis-ci.org/poetix/octarine)\r\n\r\nJava 8 magic for record types.\r\n\r\n###Quick start\r\n\r\nWe define keys, schemas, serialisers and deserialisers for two record types, `Person` and `Address`.\r\n\r\n```java\r\npublic static interface Address {\r\n    static final KeySet mandatoryKeys = new KeySet();\r\n    static final ListKey<String> addressLines = mandatoryKeys.addList(\"addressLines\");\r\n    static final Key<String> postcode = mandatoryKeys.add(\"postcode\");\r\n\r\n    Schema<Address> schema = mandatoryKeys::accept;\r\n\r\n    JsonDeserialiser reader = i ->\r\n            i.add(addressLines, i.fromList(fromString))\r\n             .add(postcode, fromString);\r\n\r\n    JsonSerialiser writer = p ->\r\n            p.add(addressLines, p.asList(asString))\r\n             .add(postcode, asString);\r\n}\r\n```\r\n\r\n```java\r\npublic static interface Person {\r\n    static final KeySet mandatoryKeys = new KeySet();\r\n    static final Key<String> name = mandatoryKeys.add(\"name\");\r\n    static final Key<Integer> age = mandatoryKeys.add(\"age\");\r\n    static final RecordKey address = mandatoryKeys.addRecord(\"address\");\r\n\r\n    Schema<Person> schema = (r, v) -> {\r\n        mandatoryKeys.accept(r, v);\r\n        age.from(r).ifPresent(a -> { if (a < 0) v.accept(\"Age must be 0 or greater\"); });\r\n        address.from(r).ifPresent(a -> Address.schema.accept(a, v));\r\n    };\r\n\r\n    JsonDeserialiser reader = i ->\r\n            i.add(name, fromString)\r\n             .add(age, fromInteger)\r\n             .add(address, Address.reader);\r\n\r\n    JsonSerialiser writer = p ->\r\n        p.add(name, asString)\r\n         .add(age, asInteger)\r\n         .add(address, Address.writer);\r\n}\r\n```\r\n\r\nWe can now read a `Person`'s details from Json, validate the record against the schema and make test assertions against it, created an updated copy with one value changed, and write the updated copy back out to Json.\r\n\r\n```java\r\n@Test public void\r\ndeserialise_validate_update_serialise() {\r\n    Record record = Person.reader.readFromString(\r\n            \"{\\\"name\\\": \\\"Arthur Putey\\\",\\n\" +\"\" +\r\n            \" \\\"age\\\": 42,\\n\" +\r\n            \" \\\"address\\\": {\\n\" +\r\n            \"   \\\"addressLines\\\": [\\\"59 Broad Street\\\", \\\"Cirencester\\\"],\\n\" +\r\n            \"   \\\"postcode\\\": \\\"RA8 81T\\\"\\n\" +\r\n            \"  }\\n\" +\r\n            \"}\");\r\n\r\n    assertThat(record, ARecord.validAgainst(Person.schema)\r\n            .with(Person.name, \"Arthur Putey\")\r\n            .with(Person.age, 42)\r\n                    // Chaining keys\r\n            .with(Person.address.join(Address.addressLines).join(Path.toIndex(0)), \"59 Broad Street\")\r\n                    // Using a sub-matcher\r\n            .with(Person.address, ARecord.validAgainst(Address.schema).with(Address.postcode, \"RA8 81T\")));\r\n\r\n    Record changed = Person.age.update(\r\n        record, age -> age.map(v -> v + 1));\r\n\r\n    assertThat(Person.writer.toString(changed), equalTo(\r\n            \"{\\\"name\\\":\\\"Arthur Putey\\\",\" +\"\" +\r\n                    \"\\\"age\\\":43,\" +\r\n                    \"\\\"address\\\":{\" +\r\n                    \"\\\"addressLines\\\":[\\\"59 Broad Street\\\",\\\"Cirencester\\\"],\" +\r\n                    \"\\\"postcode\\\":\\\"RA8 81T\\\"\" +\r\n                    \"}}\"));\r\n}\r\n```\r\n\r\n###What this is for\r\n\r\nOctarine's essential premise is as follows: *Java beans suck*. They suck because they're verbose, because they're mutable, and because they wrap a faux-\"Object-oriented\" pattern around record types with no meaningful encapsulation and no behaviour besides exposing properties.\r\n\r\nThe only thing that sucks more than Java beans is Java beans with annotations. JPA annotations. JAXB annotations. Annotations which tell frameworks how to pull data out of Java beans, or push data into them.\r\n\r\nOctarine provides you with lensable, immutable record types, that can be serialised, deserialised and validated without the use of reflection or annotations.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}